'use client';

import { useEffect, useMemo, useRef, useState } from 'react';
import { Badge, Button, Card, Col, Form, Row, Spinner } from 'react-bootstrap';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { format } from 'date-fns';
import { it } from 'date-fns/locale';
import DashboardLayout from '@/components/DashboardLayout';
import { chatApi, familyApi } from '@/lib/api';
import { useAuth } from '@/lib/AuthContext';
import StatusModal from '@/components/StatusModal';

export default function ChatPage() {
  const queryClient = useQueryClient();
  const { user } = useAuth();
  const [familyContent, setFamilyContent] = useState('');
  const [newPrivateMemberId, setNewPrivateMemberId] = useState('');
  const [manualThreadMemberIds, setManualThreadMemberIds] = useState<string[]>([]);
  const [privateDraftByMemberId, setPrivateDraftByMemberId] = useState<Record<string, string>>({});
  const [error, setError] = useState('');
  const familyMessagesRef = useRef<HTMLDivElement | null>(null);
  const privateMessagesRefs = useRef<Record<string, HTMLDivElement | null>>({});

  const { data: family } = useQuery({
    queryKey: ['family'],
    queryFn: familyApi.get,
    enabled: Boolean(user?.activeFamilyId),
  });

  const { data: messages, isLoading } = useQuery({
    queryKey: ['chat', 'messages'],
    queryFn: () => chatApi.listMessages(200),
    enabled: Boolean(user?.activeFamilyId),
    refetchInterval: 2000,
    refetchIntervalInBackground: true,
  });

  const sendFamilyMessageMutation = useMutation({
    mutationFn: (text: string) => chatApi.sendMessage(text),
    onSuccess: () => {
      setFamilyContent('');
      queryClient.invalidateQueries({ queryKey: ['chat', 'messages'] });
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
    onError: (err: Error) => setError(err.message),
  });

  const sendPrivateMessageMutation = useMutation({
    mutationFn: ({ text, recipientId }: { text: string; recipientId: string }) =>
      chatApi.sendMessage(text, recipientId),
    onSuccess: (_, vars) => {
      setPrivateDraftByMemberId((prev) => ({
        ...prev,
        [vars.recipientId]: '',
      }));
      queryClient.invalidateQueries({ queryKey: ['chat', 'messages'] });
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
    onError: (err: Error) => setError(err.message),
  });

  const sortedMessages = useMemo(
    () =>
      [...(messages ?? [])].sort(
        (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      ),
    [messages]
  );

  const familyMembers = useMemo(() => family?.users ?? [], [family]);
  const otherMembers = useMemo(
    () => familyMembers.filter((member) => member.id !== user?.id),
    [familyMembers, user?.id]
  );

  const familyChatMessages = useMemo(
    () => sortedMessages.filter((message) => !message.recipientUserId),
    [sortedMessages]
  );

  const privateMessages = useMemo(
    () => sortedMessages.filter((message) => Boolean(message.recipientUserId)),
    [sortedMessages]
  );

  const privateThreadMemberIdsFromMessages = useMemo(() => {
    const me = user?.id;
    if (!me) return [] as string[];

    const ids = new Set<string>();
    for (const message of privateMessages) {
      const senderId = message.senderUserId;
      const recipientId = message.recipientUserId;
      if (!senderId || !recipientId) continue;

      if (senderId === me && recipientId !== me) {
        ids.add(recipientId);
      } else if (recipientId === me && senderId !== me) {
        ids.add(senderId);
      }
    }

    return Array.from(ids);
  }, [privateMessages, user?.id]);

  const privateThreadMessagesByMemberId = useMemo(() => {
    const me = user?.id;
    const grouped: Record<string, typeof privateMessages> = {};

    if (!me) return grouped;

    for (const message of privateMessages) {
      const senderId = message.senderUserId;
      const recipientId = message.recipientUserId;
      if (!senderId || !recipientId) continue;

      let otherMemberId: string | null = null;
      if (senderId === me) {
        otherMemberId = recipientId;
      } else if (recipientId === me) {
        otherMemberId = senderId;
      }

      if (!otherMemberId) continue;
      if (!grouped[otherMemberId]) grouped[otherMemberId] = [];
      grouped[otherMemberId].push(message);
    }

    return grouped;
  }, [privateMessages, user?.id]);

  const threadMembersSet = useMemo(() => {
    const set = new Set(privateThreadMemberIdsFromMessages);
    for (const memberId of manualThreadMemberIds) {
      set.add(memberId);
    }
    return set;
  }, [manualThreadMemberIds, privateThreadMemberIdsFromMessages]);

  const privateThreadMembers = useMemo(() => {
    const membersById = new Map(otherMembers.map((member) => [member.id, member]));
    const latestByMemberId = new Map<string, number>();

    for (const [memberId, threadMessages] of Object.entries(privateThreadMessagesByMemberId)) {
      const lastMessage = threadMessages[threadMessages.length - 1];
      latestByMemberId.set(memberId, new Date(lastMessage.createdAt).getTime());
    }

    return Array.from(threadMembersSet)
      .map((memberId) => membersById.get(memberId))
      .filter((member): member is NonNullable<typeof member> => Boolean(member))
      .sort((a, b) => (latestByMemberId.get(b.id) ?? 0) - (latestByMemberId.get(a.id) ?? 0));
  }, [otherMembers, threadMembersSet, privateThreadMessagesByMemberId]);

  const privateAvailableMembers = useMemo(
    () => otherMembers.filter((member) => !threadMembersSet.has(member.id)),
    [otherMembers, threadMembersSet]
  );
  const privateThreadSignature = useMemo(
    () =>
      privateThreadMembers
        .map((member) => `${member.id}:${privateThreadMessagesByMemberId[member.id]?.length || 0}`)
        .join('|'),
    [privateThreadMembers, privateThreadMessagesByMemberId]
  );

  useEffect(() => {
    const validIds = new Set(otherMembers.map((member) => member.id));
    setManualThreadMemberIds((prev) => prev.filter((memberId) => validIds.has(memberId)));
  }, [otherMembers]);

  useEffect(() => {
    if (!privateAvailableMembers.length) {
      setNewPrivateMemberId('');
      return;
    }

    if (!newPrivateMemberId || !privateAvailableMembers.some((member) => member.id === newPrivateMemberId)) {
      setNewPrivateMemberId(privateAvailableMembers[0].id);
    }
  }, [newPrivateMemberId, privateAvailableMembers]);

  useEffect(() => {
    const node = familyMessagesRef.current;
    if (!node) return;
    node.scrollTop = node.scrollHeight;
  }, [familyChatMessages.length]);

  useEffect(() => {
    for (const member of privateThreadMembers) {
      const node = privateMessagesRefs.current[member.id];
      if (!node) continue;
      node.scrollTop = node.scrollHeight;
    }
  }, [privateThreadMembers, privateThreadSignature]);

  const submitFamilyMessage = () => {
    const trimmed = familyContent.trim();
    if (!trimmed || sendFamilyMessageMutation.isPending) return;
    sendFamilyMessageMutation.mutate(trimmed);
  };

  const openPrivateThread = () => {
    if (!newPrivateMemberId) return;
    setManualThreadMemberIds((prev) => (prev.includes(newPrivateMemberId) ? prev : [...prev, newPrivateMemberId]));
  };

  const submitPrivateMessage = (memberId: string) => {
    const trimmed = (privateDraftByMemberId[memberId] || '').trim();
    if (!trimmed || sendPrivateMessageMutation.isPending) return;

    sendPrivateMessageMutation.mutate({
      text: trimmed,
      recipientId: memberId,
    });
  };

  return (
    <DashboardLayout>
      <h2 className="page-title mb-4">Chat Famiglia</h2>

      <StatusModal
        show={Boolean(error)}
        variant="danger"
        message={error}
        onClose={() => setError('')}
      />

      <Card className="settings-card mb-4">
        <Card.Header>Membri della Famiglia</Card.Header>
        <Card.Body>
          {familyMembers.length ? (
            <div className="d-flex flex-column gap-2">
              {familyMembers.map((member) => (
                <div key={member.id} className="d-flex justify-content-between align-items-center">
                  <div>
                    <div className="fw-semibold">{member.id === user?.id ? 'Io' : member.name}</div>
                    <div className="small text-muted">{member.email}</div>
                  </div>
                  <Badge bg={member.role === 'admin' ? 'success' : 'secondary'}>
                    {member.role === 'admin' ? 'Amministratore' : 'Membro'}
                  </Badge>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-muted">Nessun membro disponibile.</div>
          )}
        </Card.Body>
      </Card>

      <Row className="g-4 mb-4">
        <Col xs={12}>
          <Card className="settings-card">
            <Card.Header>Chat Famiglia</Card.Header>
            <Card.Body>
              <div ref={familyMessagesRef} style={{ height: '240px', overflowY: 'auto' }} className="mb-3">
                {isLoading ? (
                  <div className="text-center py-4">
                    <Spinner animation="border" variant="success" />
                  </div>
                ) : familyChatMessages.length ? (
                  <div className="d-flex flex-column gap-2">
                    {familyChatMessages.map((message) => {
                      const isMine = message.senderUserId === user?.id;
                      const isSystem = message.messageType === 'system';

                      return (
                        <div
                          key={message.id}
                          className={`p-2 rounded ${
                            isSystem
                              ? 'bg-light text-muted'
                              : isMine
                                ? 'bg-success-subtle align-self-end'
                                : 'bg-white border'
                          }`}
                          style={{ maxWidth: isSystem ? '100%' : '85%' }}
                        >
                          {!isSystem && !isMine && (
                            <div className="small fw-semibold">{message.sender?.name || 'Utente'}</div>
                          )}
                          <div>{message.content}</div>
                          <div className="small text-muted mt-1">
                            {format(new Date(message.createdAt), 'd MMM yyyy HH:mm', { locale: it })}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                ) : (
                  <div className="text-muted">Nessun messaggio nella chat famiglia.</div>
                )}
              </div>

              <Form
                onSubmit={(e) => {
                  e.preventDefault();
                  submitFamilyMessage();
                }}
              >
                <Form.Group>
                  <Form.Control
                    as="textarea"
                    rows={3}
                    value={familyContent}
                    onChange={(e) => setFamilyContent(e.target.value)}
                    placeholder="Scrivi un messaggio alla famiglia..."
                    maxLength={2000}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.altKey) {
                        e.preventDefault();
                        submitFamilyMessage();
                      }
                    }}
                  />
                </Form.Group>
                <div className="d-flex justify-content-end mt-3">
                  <Button
                    type="submit"
                    variant="primary"
                    disabled={sendFamilyMessageMutation.isPending || !familyContent.trim()}
                  >
                    {sendFamilyMessageMutation.isPending ? <Spinner size="sm" animation="border" /> : 'Invia'}
                  </Button>
                </div>
              </Form>
            </Card.Body>
          </Card>
        </Col>
      </Row>

      <Row className="g-4">
        <Col xs={12} md={6} xl={4}>
          <Card className="settings-card h-100">
            <Card.Header>Nuova Chat Privata</Card.Header>
            <Card.Body>
              <Form.Group className="mb-3">
                <Form.Label>Seleziona membro</Form.Label>
                <Form.Select
                  value={newPrivateMemberId}
                  onChange={(e) => setNewPrivateMemberId(e.target.value)}
                  disabled={!privateAvailableMembers.length}
                >
                  {!privateAvailableMembers.length ? <option value="">Nessun membro disponibile</option> : null}
                  {privateAvailableMembers.map((member) => (
                    <option key={member.id} value={member.id}>
                      {member.name} ({member.role === 'admin' ? 'Amministratore' : 'Membro'})
                    </option>
                  ))}
                </Form.Select>
              </Form.Group>

              <Button
                variant="outline-primary"
                onClick={openPrivateThread}
                disabled={!newPrivateMemberId}
              >
                Apri box chat
              </Button>
            </Card.Body>
          </Card>
        </Col>

        {privateThreadMembers.map((member) => {
          const threadMessages = privateThreadMessagesByMemberId[member.id] || [];
          const draft = privateDraftByMemberId[member.id] || '';

          return (
            <Col key={member.id} xs={12} md={6} xl={4}>
              <Card className="settings-card h-100">
                <Card.Header className="d-flex justify-content-between align-items-center">
                  <span>{member.name}</span>
                  <Badge bg={member.role === 'admin' ? 'success' : 'secondary'}>
                    {member.role === 'admin' ? 'Amministratore' : 'Membro'}
                  </Badge>
                </Card.Header>
                <Card.Body>
                  <div
                    ref={(node) => {
                      privateMessagesRefs.current[member.id] = node;
                    }}
                    style={{ height: '240px', overflowY: 'auto' }}
                    className="mb-3"
                  >
                    {isLoading ? (
                      <div className="text-center py-4">
                        <Spinner animation="border" variant="success" />
                      </div>
                    ) : threadMessages.length ? (
                      <div className="d-flex flex-column gap-2">
                        {threadMessages.map((message) => {
                          const isMine = message.senderUserId === user?.id;
                          return (
                            <div
                              key={message.id}
                              className={`p-2 rounded ${isMine ? 'bg-success-subtle align-self-end' : 'bg-white border'}`}
                              style={{ maxWidth: '85%' }}
                            >
                              {!isMine && (
                                <div className="small fw-semibold">{message.sender?.name || 'Utente'}</div>
                              )}
                              <div>{message.content}</div>
                              <div className="small text-muted mt-1">
                                {format(new Date(message.createdAt), 'd MMM yyyy HH:mm', { locale: it })}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    ) : (
                      <div className="text-muted">Nessun messaggio privato con questo membro.</div>
                    )}
                  </div>

                  <Form
                    onSubmit={(e) => {
                      e.preventDefault();
                      submitPrivateMessage(member.id);
                    }}
                  >
                    <Form.Group>
                      <Form.Control
                        as="textarea"
                        rows={3}
                        value={draft}
                        onChange={(e) =>
                          setPrivateDraftByMemberId((prev) => ({
                            ...prev,
                            [member.id]: e.target.value,
                          }))
                        }
                        placeholder={`Scrivi un messaggio privato a ${member.name}...`}
                        maxLength={2000}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter' && !e.altKey) {
                            e.preventDefault();
                            submitPrivateMessage(member.id);
                          }
                        }}
                      />
                    </Form.Group>
                    <div className="d-flex justify-content-end mt-3">
                      <Button
                        type="submit"
                        variant="primary"
                        disabled={sendPrivateMessageMutation.isPending || !draft.trim()}
                      >
                        {sendPrivateMessageMutation.isPending ? (
                          <Spinner size="sm" animation="border" />
                        ) : (
                          'Invia'
                        )}
                      </Button>
                    </div>
                  </Form>
                </Card.Body>
              </Card>
            </Col>
          );
        })}
      </Row>
    </DashboardLayout>
  );
}
